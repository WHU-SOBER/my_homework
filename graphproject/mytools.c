#include<stdio.h>
#include<stdlib.h>
#include"mytools.h"

/*********************************************************************************/
/*********************************************************************************/
/******************************常用函数实现区***************************************/
/*********************************************************************************/
/*********************************************************************************/

//返回start->end有向边的权重
int getWeight(int start, int end, NODE *list[])
{
	NODE* temp = list[start]->next;
	while (temp != NULL)
	{
		if (temp->num == end)
			return temp->weight;
		temp = temp->next;
	}
	return 0x3f3f3f3f;
}

/*********************************************************************************/
/*********************************************************************************/
/******************************栈函数实现区****************************************/
/*********************************************************************************/
/*********************************************************************************/


//栈初始化函数，为栈指针s申请动态内存，同时将所有边的起点、终点、权重初始化为-1
void initStack(STACK **s)
{
	*s = (STACK*)malloc(sizeof(STACK));
	(*s)->top = -1;
	for (int i = 0; i < MAXSIZE; i++)
	{
		(*s)->data[i] = -1;
	}
}

//判断栈空的函数，栈空则返回1，否则返回0
int is_emptyStack(STACK *s)
{
	if (s->top == -1)
		return 1;
	else
		return 0;
}

//判断栈满的函数，栈空则返回1，否则返回0
int is_fullStack(STACK *s)
{
	if (s->top == MAXSIZE - 1)
		return 1;
	else
		return 0;
}

//压栈函数，接收EDGE*类型的数据压栈。正常返回值为0，如果栈满则返回-1
int push(int n, STACK *s)
{
	if (s->top == MAXSIZE - 1)
		return -1;
	s->top++;
	s->data[s->top] = n;
	return 0;
}

//出栈函数，将栈顶元素泵出。正常返回值为0，如果栈空则返回-1
int pop(STACK *s)
{
	if (s->top == -1)
		return -1;
	s->data[s->top] = -1;
	s->top--;
	return s->data[s->top + 1];
}

//取栈顶元素函数，但是并不影响栈顶指针。正常返回值为0，如果栈空则返回-1
int get(STACK *s)
{
	if (s->top == -1)
		return -1;
	return s->data[s->top];
}

//栈删除函数，释放栈所占内存区域，指针放空
void delStack(STACK *s)
{
	free(s);
	s = NULL;
}

/*********************************************************************************/
/*********************************************************************************/
/******************************队列函数实现区***************************************/
/*********************************************************************************/
/*********************************************************************************/

//队列初始化函数，为队列指针s申请动态内存，同时将所有边的起点、终点、权重初始化为-1
void initQueue(QUEUE *q)
{
	q = (QUEUE*)malloc(sizeof(QUEUE));
	q->front = 0;
	q->rear = 0;
}

//判断队空函数，队空则返回1，否则返回0
int is_emptyQueue(QUEUE *q)
{
	if (q->front == q->rear)
		return 1;
	else
		return 0;
};

//判断队满函数，队满则返回1，否则返回0
int is_fullQueue(QUEUE *q)
{
	if (q->front == (q->rear + 1) % MAXSIZE)    //推断循环链表是否满，留一个预留空间不用
		return 1;
	else
		return 0;
}

//入队函数，接收int类型的数据入队尾。正常返回值为0，如果队满则返回-1
int enqueue(int n, QUEUE *q)
{
	if (is_fullQueue(q))
		return -1;
	q->data[q->rear] = n;
	q->rear = (q->rear + 1) % MAXSIZE;
	return 0;
}

//出队函数， 将队头元素出队并返回.正常返回值为0，如果队空则返回-1
int dequeue(QUEUE *q)
{
	if (is_emptyQueue(q))
		return -1;
	int result = q->data[q->front];
	q->front = (q->front + 1) % MAXSIZE;
	return result;
}

//队列删除函数,释放队列所占内存区域，指针放空
int delQueue(QUEUE *q)
{
	free(q);
	q = NULL;
}